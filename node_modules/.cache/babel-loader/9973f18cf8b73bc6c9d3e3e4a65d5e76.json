{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { WalletNotConnectedError, WalletNotReadyError } from '@solana/wallet-adapter-base';\nimport { computed, inject, provide, ref, watch, watchEffect } from '@vue/runtime-core';\nimport { WalletNotSelectedError } from './errors.mjs';\nimport { useLocalStorage } from './useLocalStorage.mjs';\nconst walletStoreKey = Symbol();\nlet globalWalletStore = null;\nexport const useWallet = () => {\n  const providedWalletStore = inject(walletStoreKey, undefined);\n  if (providedWalletStore) return providedWalletStore;\n  if (globalWalletStore) return globalWalletStore;\n  throw new Error('Wallet not initialized. Please use the `WalletProvider` component to initialize the wallet.');\n};\nexport const provideWallet = walletStoreProps => {\n  provide(walletStoreKey, createWalletStore(walletStoreProps));\n};\nexport const initWallet = walletStoreProps => {\n  globalWalletStore = createWalletStore(walletStoreProps);\n};\nexport const createWalletStore = ({\n  wallets,\n  autoConnect = false,\n  onError = error => console.error(error),\n  localStorageKey = 'walletName'\n}) => {\n  const name = useLocalStorage(localStorageKey);\n  const wallet = ref(null);\n  const adapter = ref(null);\n  const publicKey = ref(null);\n  const ready = ref(false);\n  const connected = ref(false);\n  const connecting = ref(false);\n  const disconnecting = ref(false); // Helper methods to set and reset the main state variables.\n\n  const setState = state => {\n    wallet.value = state.wallet;\n    adapter.value = state.adapter;\n    ready.value = state.ready;\n    publicKey.value = state.publicKey;\n    connected.value = state.connected;\n  };\n\n  const resetState = () => {\n    setState({\n      wallet: null,\n      adapter: null,\n      ready: false,\n      publicKey: null,\n      connected: false\n    });\n  }; // Create a wallet dictionary keyed by their name.\n\n\n  const walletsByName = computed(() => {\n    return wallets.reduce((walletsByName, wallet) => {\n      walletsByName[wallet.name] = wallet;\n      return walletsByName;\n    }, {});\n  }); // Update the wallet and adapter based on the wallet provider.\n\n  watch(name, () => {\n    var _a, _b;\n\n    const wallet = (_b = (_a = walletsByName.value) === null || _a === void 0 ? void 0 : _a[name.value]) !== null && _b !== void 0 ? _b : null;\n    const adapter = wallet && wallet.adapter;\n\n    if (adapter) {\n      setState({\n        wallet,\n        adapter,\n        ready: false,\n        publicKey: adapter.publicKey,\n        connected: adapter.connected\n      }); // Asynchronously update the ready state\n\n      const waiting = name;\n\n      (async function () {\n        const readyValue = await adapter.ready(); // If the selected wallet hasn't changed while waiting, update the ready state\n\n        if (name === waiting) {\n          ready.value = readyValue;\n        }\n      })();\n    } else {\n      resetState();\n    }\n  }, {\n    immediate: true\n  }); // Select a wallet by name.\n\n  const select = async walletName => {\n    if (name.value === walletName) return;\n    if (adapter.value) await adapter.value.disconnect();\n    name.value = walletName;\n  }; // Handle the adapter events.\n\n\n  const onDisconnect = () => name.value = null;\n\n  const onConnect = () => {\n    if (!adapter.value) return;\n    publicKey.value = adapter.value.publicKey;\n    connected.value = adapter.value.connected;\n  };\n\n  const invalidateListeners = watchEffect(onInvalidate => {\n    const _adapter = adapter.value;\n    if (!_adapter) return;\n\n    _adapter.on('connect', onConnect);\n\n    _adapter.on('disconnect', onDisconnect);\n\n    _adapter.on('error', onError);\n\n    onInvalidate(() => {\n      _adapter.off('connect', onConnect);\n\n      _adapter.off('disconnect', onDisconnect);\n\n      _adapter.off('error', onError);\n    });\n  });\n\n  if (typeof window !== 'undefined') {\n    // Ensure the adapter listeners are invalidated before refreshing the page.\n    // This is because Vue does not unmount components when the page is being refreshed.\n    window.addEventListener('beforeunload', invalidateListeners);\n  } // Helper method to return an error whilst using the onError callback.\n\n\n  const newError = error => {\n    onError(error);\n    return error;\n  }; // Connect the adapter to the wallet.\n\n\n  const connect = async () => {\n    if (connected.value || connecting.value || disconnecting.value) return;\n    if (!wallet.value || !adapter.value) throw newError(new WalletNotSelectedError());\n\n    if (!ready.value) {\n      name.value = null;\n\n      if (typeof window !== 'undefined') {\n        window.open(wallet.value.url, '_blank');\n      }\n\n      throw newError(new WalletNotReadyError());\n    }\n\n    try {\n      connecting.value = true;\n      await adapter.value.connect();\n    } catch (error) {\n      name.value = null;\n      throw error;\n    } finally {\n      connecting.value = false;\n    }\n  }; // Disconnect the adapter from the wallet.\n\n\n  const disconnect = async () => {\n    if (disconnecting.value) return;\n\n    if (!adapter.value) {\n      name.value = null;\n      return;\n    }\n\n    try {\n      disconnecting.value = true;\n      await adapter.value.disconnect();\n    } finally {\n      name.value = null;\n      disconnecting.value = false;\n    }\n  }; // Send a transaction using the provided connection.\n\n\n  const sendTransaction = async (transaction, connection, options) => {\n    if (!adapter.value) throw newError(new WalletNotSelectedError());\n    if (!connected.value) throw newError(new WalletNotConnectedError());\n    return await adapter.value.sendTransaction(transaction, connection, options);\n  }; // Sign a transaction if the wallet supports it.\n\n\n  const signTransaction = computed(() => {\n    const _adapter = adapter.value;\n    if (!(_adapter && 'signTransaction' in _adapter)) return;\n    return async transaction => {\n      if (!connected.value) throw newError(new WalletNotConnectedError());\n      return await _adapter.signTransaction(transaction);\n    };\n  }); // Sign multiple transactions if the wallet supports it\n\n  const signAllTransactions = computed(() => {\n    const _adapter = adapter.value;\n    if (!(_adapter && 'signAllTransactions' in _adapter)) return;\n    return async transactions => {\n      if (!connected.value) throw newError(new WalletNotConnectedError());\n      return await _adapter.signAllTransactions(transactions);\n    };\n  }); // Sign an arbitrary message if the wallet supports it.\n\n  const signMessage = computed(() => {\n    const _adapter = adapter.value;\n    if (!(_adapter && 'signMessage' in _adapter)) return;\n    return async message => {\n      if (!connected.value) throw newError(new WalletNotConnectedError());\n      return await _adapter.signMessage(message);\n    };\n  }); // If autoConnect is enabled, try to connect when the adapter changes and is ready.\n\n  watchEffect(async () => {\n    if (!autoConnect || !adapter.value || !ready.value || connected.value || connecting.value) return;\n\n    try {\n      connecting.value = true;\n      await adapter.value.connect();\n    } catch (error) {\n      // Clear the selected wallet\n      name.value = null; // Don't throw error, but onError will still be called\n    } finally {\n      connecting.value = false;\n    }\n  }); // Return the created store.\n\n  return {\n    // Props.\n    wallets,\n    autoConnect,\n    // Data.\n    wallet,\n    adapter,\n    publicKey,\n    ready,\n    connected,\n    connecting,\n    disconnecting,\n    // Methods.\n    select,\n    connect,\n    disconnect,\n    sendTransaction,\n    signTransaction,\n    signAllTransactions,\n    signMessage\n  };\n};","map":{"version":3,"sources":["../../src/useWallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { WalletNotConnectedError, WalletNotReadyError, } from '@solana/wallet-adapter-base';\nimport { computed, inject, provide, ref, watch, watchEffect } from '@vue/runtime-core';\nimport { WalletNotSelectedError } from './errors.mjs';\nimport { useLocalStorage } from './useLocalStorage.mjs';\nconst walletStoreKey = Symbol();\nlet globalWalletStore = null;\nexport const useWallet = () => {\n    const providedWalletStore = inject(walletStoreKey, undefined);\n    if (providedWalletStore)\n        return providedWalletStore;\n    if (globalWalletStore)\n        return globalWalletStore;\n    throw new Error('Wallet not initialized. Please use the `WalletProvider` component to initialize the wallet.');\n};\nexport const provideWallet = (walletStoreProps) => {\n    provide(walletStoreKey, createWalletStore(walletStoreProps));\n};\nexport const initWallet = (walletStoreProps) => {\n    globalWalletStore = createWalletStore(walletStoreProps);\n};\nexport const createWalletStore = ({ wallets, autoConnect = false, onError = (error) => console.error(error), localStorageKey = 'walletName', }) => {\n    const name = useLocalStorage(localStorageKey);\n    const wallet = ref(null);\n    const adapter = ref(null);\n    const publicKey = ref(null);\n    const ready = ref(false);\n    const connected = ref(false);\n    const connecting = ref(false);\n    const disconnecting = ref(false);\n    // Helper methods to set and reset the main state variables.\n    const setState = (state) => {\n        wallet.value = state.wallet;\n        adapter.value = state.adapter;\n        ready.value = state.ready;\n        publicKey.value = state.publicKey;\n        connected.value = state.connected;\n    };\n    const resetState = () => {\n        setState({\n            wallet: null,\n            adapter: null,\n            ready: false,\n            publicKey: null,\n            connected: false,\n        });\n    };\n    // Create a wallet dictionary keyed by their name.\n    const walletsByName = computed(() => {\n        return wallets.reduce((walletsByName, wallet) => {\n            walletsByName[wallet.name] = wallet;\n            return walletsByName;\n        }, {});\n    });\n    // Update the wallet and adapter based on the wallet provider.\n    watch(name, () => {\n        var _a, _b;\n        const wallet = (_b = (_a = walletsByName.value) === null || _a === void 0 ? void 0 : _a[name.value]) !== null && _b !== void 0 ? _b : null;\n        const adapter = wallet && wallet.adapter;\n        if (adapter) {\n            setState({\n                wallet,\n                adapter,\n                ready: false,\n                publicKey: adapter.publicKey,\n                connected: adapter.connected,\n            });\n            // Asynchronously update the ready state\n            const waiting = name;\n            (async function () {\n                const readyValue = await adapter.ready();\n                // If the selected wallet hasn't changed while waiting, update the ready state\n                if (name === waiting) {\n                    ready.value = readyValue;\n                }\n            })();\n        }\n        else {\n            resetState();\n        }\n    }, { immediate: true });\n    // Select a wallet by name.\n    const select = async (walletName) => {\n        if (name.value === walletName)\n            return;\n        if (adapter.value)\n            await adapter.value.disconnect();\n        name.value = walletName;\n    };\n    // Handle the adapter events.\n    const onDisconnect = () => (name.value = null);\n    const onConnect = () => {\n        if (!adapter.value)\n            return;\n        publicKey.value = adapter.value.publicKey;\n        connected.value = adapter.value.connected;\n    };\n    const invalidateListeners = watchEffect((onInvalidate) => {\n        const _adapter = adapter.value;\n        if (!_adapter)\n            return;\n        _adapter.on('connect', onConnect);\n        _adapter.on('disconnect', onDisconnect);\n        _adapter.on('error', onError);\n        onInvalidate(() => {\n            _adapter.off('connect', onConnect);\n            _adapter.off('disconnect', onDisconnect);\n            _adapter.off('error', onError);\n        });\n    });\n    if (typeof window !== 'undefined') {\n        // Ensure the adapter listeners are invalidated before refreshing the page.\n        // This is because Vue does not unmount components when the page is being refreshed.\n        window.addEventListener('beforeunload', invalidateListeners);\n    }\n    // Helper method to return an error whilst using the onError callback.\n    const newError = (error) => {\n        onError(error);\n        return error;\n    };\n    // Connect the adapter to the wallet.\n    const connect = async () => {\n        if (connected.value || connecting.value || disconnecting.value)\n            return;\n        if (!wallet.value || !adapter.value)\n            throw newError(new WalletNotSelectedError());\n        if (!ready.value) {\n            name.value = null;\n            if (typeof window !== 'undefined') {\n                window.open(wallet.value.url, '_blank');\n            }\n            throw newError(new WalletNotReadyError());\n        }\n        try {\n            connecting.value = true;\n            await adapter.value.connect();\n        }\n        catch (error) {\n            name.value = null;\n            throw error;\n        }\n        finally {\n            connecting.value = false;\n        }\n    };\n    // Disconnect the adapter from the wallet.\n    const disconnect = async () => {\n        if (disconnecting.value)\n            return;\n        if (!adapter.value) {\n            name.value = null;\n            return;\n        }\n        try {\n            disconnecting.value = true;\n            await adapter.value.disconnect();\n        }\n        finally {\n            name.value = null;\n            disconnecting.value = false;\n        }\n    };\n    // Send a transaction using the provided connection.\n    const sendTransaction = async (transaction, connection, options) => {\n        if (!adapter.value)\n            throw newError(new WalletNotSelectedError());\n        if (!connected.value)\n            throw newError(new WalletNotConnectedError());\n        return await adapter.value.sendTransaction(transaction, connection, options);\n    };\n    // Sign a transaction if the wallet supports it.\n    const signTransaction = computed(() => {\n        const _adapter = adapter.value;\n        if (!(_adapter && 'signTransaction' in _adapter))\n            return;\n        return async (transaction) => {\n            if (!connected.value)\n                throw newError(new WalletNotConnectedError());\n            return await _adapter.signTransaction(transaction);\n        };\n    });\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions = computed(() => {\n        const _adapter = adapter.value;\n        if (!(_adapter && 'signAllTransactions' in _adapter))\n            return;\n        return async (transactions) => {\n            if (!connected.value)\n                throw newError(new WalletNotConnectedError());\n            return await _adapter.signAllTransactions(transactions);\n        };\n    });\n    // Sign an arbitrary message if the wallet supports it.\n    const signMessage = computed(() => {\n        const _adapter = adapter.value;\n        if (!(_adapter && 'signMessage' in _adapter))\n            return;\n        return async (message) => {\n            if (!connected.value)\n                throw newError(new WalletNotConnectedError());\n            return await _adapter.signMessage(message);\n        };\n    });\n    // If autoConnect is enabled, try to connect when the adapter changes and is ready.\n    watchEffect(async () => {\n        if (!autoConnect || !adapter.value || !ready.value || connected.value || connecting.value)\n            return;\n        try {\n            connecting.value = true;\n            await adapter.value.connect();\n        }\n        catch (error) {\n            // Clear the selected wallet\n            name.value = null;\n            // Don't throw error, but onError will still be called\n        }\n        finally {\n            connecting.value = false;\n        }\n    });\n    // Return the created store.\n    return {\n        // Props.\n        wallets,\n        autoConnect,\n        // Data.\n        wallet,\n        adapter,\n        publicKey,\n        ready,\n        connected,\n        connecting,\n        disconnecting,\n        // Methods.\n        select,\n        connect,\n        disconnect,\n        sendTransaction,\n        signTransaction,\n        signAllTransactions,\n        signMessage,\n    };\n};\n//# sourceMappingURL=useWallet.js.map"]},"metadata":{},"sourceType":"module"}